{"version":3,"sources":["components/Slider.js","models/Constants.js","models/Config.js","algorithms/TreeAlgorithms.js","View/NodeInPath.js","models/Node.js","View/Visualizer.js","components/Dropdown.js","components/Header.js","components/Canvas.js","components/Content.js","components/Footer.js","models/AvlTree.js","models/BinarySearchTree.js","models/DrawableNode.js","models/DrawableAvlTree.js","components/App.js","index.js"],"names":["Slider","props","values","useState","min_value","value","setValue","type","min","max","max_value","step","onChange","e","sliderValue","target","parseInt","constants","CANVAS_MAXIMUM_WIDTH","CANVAS_MAXIMUM_HEIGHT","MAXIMUM_NODES","MINIMUM_NODES","NODE_RADIUS","NODE_DRAW_FONT","NODE_PATH_COLOR","NODE_SELECTED_COLOR","NODE_CURRENT_COLOR","MINIMUM_SPEED","MAXIMUM_SPEED","getCanvasMaximumWidth","getCanvasMaximumHeight","getMinimumNodes","getMaximumNodes","getMinimumSpeed","getCanvasDrawFont","getCanvasNodeRadius","getCanvasNodeSelectedColor","treeDiameterPaths","root","possibleNodes","maxDistance","treeDiameterPossibleNodes","mostDistantPairs","i","length","n1","element","j","n2","lowestComAnc","lowestCommonAncestor","findDistance","path1","pathToNode","shift","reverse","path2","path","push","startNode","endNode","node","arr","lHeight","calculateHeight","left","rHeight","lDiameter","rDiameter","right","Math","findLevel","a","level","searchNodesBetween","avl","pathNodes","searchNodesHelper","findNode","elementToFind","NodeInPath","this","TYPES","Node","visualizeFind","ctx","speed","algorithms","pathNodesInPath","animatePath","current","oneByOneArray","appendableNodes","visualizePath","setTimeout","clearRect","canvas","width","height","visualize","floor","configs","x","y","font","beginPath","arc","PI","stroke","currNode","nodeInPath","findNodeInPathWithNode","fillStyle","fill","fillNodeCircle","closePath","textAlign","strokeText","newX","canvasPos","newY","strokeLine","initialX","initialY","finalX","finalY","radius","moveTo","lineTo","Dropdown","info","className","defaultValue","disabled","defaultText","options","map","item","text","Header","React","forwardRef","canvasRef","useContext","AVLContext","MAX_ITERATIONS","Object","defineProperty","writable","currentAlgorithm","nodeSliderProps","iterations","size","random","insert","remove","obtainRandomNodeElement","window","dispatchEvent","Event","speedSliderProps","runAlgorithm","getContext","selectedNodes","alert","loopFind","visualizer","pathObjects","visualizePaths","forEach","minNode","Number","MAX_VALUE","maxNode","MIN_VALUE","nodesBetween","dropDownOptions","inOrderNodes","filter","isSelected","changeSelectStatus","style","display","flexDirection","justifyContent","flexBasis","onClick","Canvas","ref","useEffect","context","render","draw","clickCanvasPos","rect","getBoundingClientRect","actualWidth","actualHeight","clickedX","clientX","clickedY","clientY","top","canvasPosX","canvasPosY","getNodeInPosition","dNode","handleResize","parent","parentNode","styles","getComputedStyle","w","getPropertyValue","h","fillBinaryTree","addEventListener","removeEventListener","Content","Footer","href","AVLTree","nodeHeight","leftNode","rightLeftNode","updateHeight","rightNode","leftRightNode","balanceFactor","leftRotation","rightRotation","bf","insertNode","balanceNode","inOrder","removeNode","smallElem","smallestElementOfSubtree","calcSize","newNode","smallestElement","snapshot","inOrderNodeSubtree","inOrderSubtree","DrawableNode","canvasX","canvasY","isInRange","num","DrawableAvlTree","nodeRadius","heightIncrease","canvasWidth","canvasHeight","treeHeight","ratio","shouldBe","pow","settleCanvasWidth","settleCanvasHeight","drawTree","isLeft","newPos","getPosition","isInPosition","AvlTree","createContext","App","useRef","Provider","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ebd360d1.chunk.js","sourcesContent":["\r\nimport React, { useState } from 'react'\r\n\r\nexport default function Slider(props) {\r\n    const values = props.props;\r\n    const [value, setValue] = useState(values.min_value);\r\n    const handleOnChange = (e) => {\r\n        let sliderValue = e.target.value;\r\n        // for example, if step is 20 starts at 10 and max is 1000, the max value for the slider would actually be only 990, so if it is 990, put it to max\r\n        if (parseInt(sliderValue) + parseInt(values.step) > parseInt(values.max_value)) {\r\n            sliderValue = values.max_value;\r\n        }\r\n        setValue(sliderValue);\r\n\r\n        values.onChange(sliderValue);\r\n    }\r\n    return (\r\n        <input type=\"range\" min={values.min_value} max={values.max_value} step={values.step} value={value} onChange={handleOnChange}></input>\r\n    )\r\n}\r\n","const constants = {\r\n    CANVAS_MAXIMUM_WIDTH : 32767,\r\n    CANVAS_MAXIMUM_HEIGHT: 32767,\r\n    MAXIMUM_NODES : 120,\r\n    MINIMUM_NODES:  20,\r\n    NODE_RADIUS: 25,\r\n    NODE_DRAW_FONT: '15px Arial',\r\n    NODE_PATH_COLOR: 'yellow',\r\n    NODE_SELECTED_COLOR: '#00FFFF',\r\n    NODE_CURRENT_COLOR :'green',\r\n    MINIMUM_SPEED:10,\r\n    MAXIMUM_SPEED:1000\r\n};\r\nexport default constants;","import constants from './Constants.js';\r\n\r\nexport function getCanvasMaximumWidth() {\r\n    return constants.CANVAS_MAXIMUM_WIDTH;\r\n}\r\nexport function getCanvasMaximumHeight() {\r\n    return constants.CANVAS_MAXIMUM_HEIGHT;\r\n}\r\nexport function getMinimumNodes() {\r\n    return constants.MINIMUM_NODES;\r\n}\r\nexport function getMaximumNodes() {\r\n    return constants.MAXIMUM_NODES;\r\n}\r\nexport function getMinimumSpeed() {\r\n    return constants.MINIMUM_SPEED;\r\n}\r\nexport function getMaximumSpeed() {\r\n    return constants.MAXIMUM_SPEED;\r\n}\r\nexport function getCanvasDrawFont() {\r\n    return constants.NODE_DRAW_FONT;\r\n} \r\nexport function getCanvasNodeRadius() {\r\n    return constants.NODE_RADIUS;\r\n}\r\nexport function getPathNodeColor() {\r\n    return constants.NODE_PATH_COLOR;\r\n} \r\nexport function getCanvasNodeSelectedColor() {\r\n    return constants.NODE_SELECTED_COLOR;\r\n}\r\nexport function getPathCurrentNodeColor() {\r\n    return constants.NODE_CURRENT_COLOR;\r\n}","export function treeDiameterPaths(root) {\r\n    const possibleNodes = [];\r\n    const maxDistance = treeDiameterPossibleNodes(root, possibleNodes);\r\n    const mostDistantPairs = [];\r\n    for ( let i = 0; i < possibleNodes.length; i++) {\r\n        let n1 = possibleNodes[i].element;\r\n        for (let j = i + 1; j < possibleNodes.length; j++) {\r\n            let n2 = possibleNodes[j].element;\r\n\r\n            let lowestComAnc = lowestCommonAncestor(root, n1, n2);\r\n\r\n            let distance = findDistance(lowestComAnc, n1, n2);\r\n            if (distance === maxDistance ){\r\n                let path1 = pathToNode(lowestComAnc,n1); // remove lca\r\n                path1.shift();\r\n                path1.reverse();    \r\n                let path2 = pathToNode(lowestComAnc,n2);\r\n                const path = [...path1,...path2];\r\n                mostDistantPairs.push({startNode : possibleNodes[i], path: path,endNode: possibleNodes[j]});\r\n            }\r\n\r\n        }\r\n    }\r\n    return mostDistantPairs;\r\n}\r\nfunction treeDiameterPossibleNodes(node, arr) {\r\n    if (node == null) {\r\n        return -1;\r\n    }\r\n    let lHeight = calculateHeight(node.left);\r\n    let rHeight = calculateHeight(node.left);\r\n    let lDiameter = treeDiameterPossibleNodes(node.left, arr);\r\n    let rDiameter = treeDiameterPossibleNodes(node.right, arr);\r\n    // if 0, it is one of the furthest childs and it is possible that it is a part of a furthest path \r\n    if (Math.max(lHeight + rHeight,\r\n        Math.max(lDiameter, rDiameter)) === 0) {\r\n        arr.push(node);\r\n    }\r\n    // max se passar pela root lHeight + rHeight\r\n    // max se não passar pela root Math.max(lDiameter, rDiameter)\r\n    return Math.max(lHeight + rHeight,\r\n        Math.max(lDiameter, rDiameter));\r\n}\r\nfunction calculateHeight(node) {\r\n    if (node === null) {\r\n        return 0;\r\n    }\r\n    let lHeight = calculateHeight(node.left);\r\n    let rHeight = calculateHeight(node.right);\r\n\r\n\r\n    return lHeight > rHeight ? lHeight + 1 : rHeight + 1;\r\n}\r\nfunction lowestCommonAncestor(node,  n1,  n2) {\r\n    if (node == null) {\r\n        return node;\r\n    }\r\n    if (node.element === n1 ||node.element === n2 ) {\r\n        return node;\r\n    }\r\n\r\n    let left = lowestCommonAncestor(node.left, n1, n2);\r\n    let right = lowestCommonAncestor(node.right, n1, n2);\r\n\r\n    if (left !== null && right !== null) {\r\n        return node;\r\n    }\r\n    if (left === null && right === null) {\r\n        return null;\r\n    }\r\n    if (left != null) {\r\n        return lowestCommonAncestor(node.left, n1, n2);\r\n    } else {\r\n        return lowestCommonAncestor(node.right, n1, n2);\r\n    }\r\n}\r\n\r\nfunction findDistance(lowestComAnc, n1, n2) {\r\n    return findLevel(lowestComAnc, n1, 0) + findLevel(lowestComAnc, n2, 0);\r\n}\r\nfunction findLevel( root,  a, level) {\r\n    if (root == null) {\r\n        return -1;\r\n    }\r\n\r\n    if (root.element === a) {\r\n        return level;\r\n    }\r\n    let left = findLevel(root.left, a, level + 1);\r\n    if (left === -1) {\r\n        return findLevel(root.right, a, level + 1);\r\n    }\r\n    return left;\r\n}\r\nfunction pathToNode(node,element,path=[]) {\r\n    if (node === null) {\r\n        return null;\r\n    }\r\n    if (element === node.element) {\r\n        return path;\r\n    }\r\n    path.push(node);\r\n\r\n    if (node.element > element) {\r\n        return pathToNode(node.left,element,path);\r\n    }\r\n    else {\r\n        return pathToNode(node.right,element,path);\r\n    }\r\n}\r\nexport function searchNodesBetween(min, max, avl) {\r\n    const pathNodes = [];\r\n    searchNodesHelper(min, max, avl.root, pathNodes);\r\n    return pathNodes;\r\n}\r\nfunction searchNodesHelper(min, max, node, pathNodes = []) {\r\n    if (node === null) {\r\n        return;\r\n    }\r\n    if (min < node.element && node.element < max) {\r\n        pathNodes.push(node);\r\n    }\r\n    if (node.element <= max) {\r\n        searchNodesHelper(min, max, node.right, pathNodes);\r\n    }\r\n    if (node.element >= min) {\r\n        searchNodesHelper(min, max, node.left, pathNodes);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function findNode(elementToFind, node, pathNodes = []) {\r\n    if (node === null) {\r\n        return null;\r\n    }\r\n    pathNodes.push(node);\r\n\r\n    if (elementToFind === node.element) {\r\n        return pathNodes;\r\n    }\r\n    if (node.element > elementToFind) {\r\n        return findNode(elementToFind, node.left, pathNodes);\r\n    }\r\n    else {\r\n        return findNode(elementToFind, node.right, pathNodes);\r\n    }\r\n}","export  class NodeInPath {\r\n    constructor(node,type) {\r\n        this.node = node;\r\n        this.type = type;\r\n    }\r\n}\r\nexport const TYPES = {\r\n    CURRENT: 'current',\r\n    IN_PATH: 'in_path',\r\n    SOURCE_OR_DESTINATION: 'sdst',\r\n    NOT_YET_TRAVERSED: ''\r\n\r\n};","export default class Node {\r\n    constructor(element) {\r\n        this.element = element;\r\n        this.left = null;\r\n        this.right =null;\r\n        this.level = 0;\r\n    }\r\n}\r\n","import * as configs from '../models/Config.js';\r\nimport * as algorithms from '../algorithms/TreeAlgorithms.js';\r\nimport { NodeInPath, TYPES } from './NodeInPath.js';\r\nimport Node from '../models/Node.js';\r\n//Assumes node positions are set\r\n\r\n\r\nexport function visualizeTreeDiameterPaths(avl, ctx, speed) {\r\n    const pathObjects = algorithms.treeDiameterPaths(avl.root);\r\n    const visualizePaths = (i) => {\r\n        if (i >= pathObjects.length) return;\r\n        let pathNodes = [];\r\n        pathObjects[i].path.forEach(node => {\r\n            pathNodes.push(new NodeInPath(node, TYPES.IN_PATH));\r\n        });\r\n        animatePath(avl, ctx, pathNodes, 1, speed, [], [new NodeInPath(pathObjects[i].startNode, TYPES.SOURCE_OR_DESTINATION), new NodeInPath(pathObjects[i].endNode, TYPES.SOURCE_OR_DESTINATION)]);\r\n        // make it go very fast if user isn't trying to analyze it\r\n        setTimeout(function() {visualizePaths(++i)}, speed * pathObjects[i].path.length + (speed > 150 ? 1000 : 50));\r\n    }\r\n    visualizePaths(0);\r\n}\r\nexport function visualizeAllBetweenChosenNodes(avl, ctx, speed) {\r\n    if (avl.selectedNodes.length < 2) {\r\n        return;\r\n    }\r\n    let minNode = new Node(Number.MAX_VALUE);\r\n    let maxNode = new Node(Number.MIN_VALUE);\r\n    // find min and max from set of nodes\r\n    avl.selectedNodes.forEach(node => {\r\n        if (minNode.element > node.element) {\r\n            minNode = node;\r\n        }\r\n        if (maxNode.element < node.element) {\r\n            maxNode = node;\r\n        }\r\n    });\r\n    const nodesBetween = algorithms.searchNodesBetween(minNode.element, maxNode.element, avl);\r\n    const pathNodes = [];\r\n    nodesBetween.forEach(node => {\r\n        pathNodes.push(new NodeInPath(node, TYPES.IN_PATH));\r\n    });\r\n    animatePath(avl, ctx, pathNodes, 1, speed, [], [new NodeInPath(minNode, TYPES.SOURCE_OR_DESTINATION), new NodeInPath(maxNode, TYPES.SOURCE_OR_DESTINATION)]);\r\n}\r\n\r\nexport function visualizeFind(avl, ctx, elementToFind, speed) {\r\n    if (avl.root === null) {\r\n        return null;\r\n    }\r\n    const pathNodes = algorithms.findNode(elementToFind, avl.root);\r\n    const pathNodesInPath = [];\r\n    pathNodesInPath.push(new NodeInPath(pathNodes[0], TYPES.SOURCE_OR_DESTINATION));\r\n    for (let i = 1; i < pathNodes.length - 1; i++) {\r\n        pathNodesInPath.push(new NodeInPath(pathNodes[i], TYPES.IN_PATH));\r\n    }\r\n    pathNodesInPath.push(new NodeInPath(pathNodes[pathNodes.length - 1], TYPES.SOURCE_OR_DESTINATION));\r\n\r\n    animatePath(avl, ctx, pathNodesInPath, 1, speed);\r\n\r\n}\r\nfunction animatePath(avl, ctx, pathNodes, current, speed, oneByOneArray = [], appendableNodes = []) {\r\n    if (current > pathNodes.length) {\r\n        return;\r\n    }\r\n    if (current < pathNodes.length && current !== 1) {\r\n        pathNodes[current - 1].type = TYPES.CURRENT;\r\n    }\r\n    if (current > 2) { // no longer the current one\r\n        pathNodes[current - 2].type = TYPES.IN_PATH;\r\n    }\r\n    for (let i = oneByOneArray.length; i < current; i++) {\r\n        oneByOneArray.push(pathNodes[i]);\r\n    }\r\n    visualizePath(avl, ctx, [...oneByOneArray, ...appendableNodes]);\r\n    setTimeout(function () {\r\n        animatePath(avl, ctx, pathNodes, ++current, speed, oneByOneArray, appendableNodes);\r\n    }, speed[0]);\r\n\r\n}\r\nfunction visualizePath(avl, ctx, pathNodes = []) {\r\n    if (pathNodes.length === 0) return;\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n    visualize(avl.root, ctx, Math.floor(ctx.canvas.width / 2), ctx.canvas.height - ctx.canvas.height + configs.getCanvasNodeRadius(), pathNodes);\r\n}\r\nfunction visualize(node, ctx, x, y, pathNodes) {\r\n    ctx.font = configs.getCanvasDrawFont();\r\n    ctx.beginPath();\r\n    ctx.arc(x, y, configs.getCanvasNodeRadius(), 0, 2 * Math.PI);\r\n    ctx.stroke();\r\n    fillNodeCircle(ctx, node, pathNodes);\r\n    ctx.closePath();\r\n    ctx.textAlign = \"center\";\r\n    ctx.strokeText(node.element, x, y + 5);\r\n    if (node.left !== null) {\r\n        let newX = node.left.canvasPos.x;\r\n        let newY = node.left.canvasPos.y;\r\n        strokeLine(ctx, x, y, newX, newY);\r\n        visualize(node.left, ctx, newX, newY, pathNodes);\r\n    }\r\n    if (node.right !== null) {\r\n        let newX = node.right.canvasPos.x;\r\n        let newY = node.right.canvasPos.y;\r\n        strokeLine(ctx, x, y, newX, newY);\r\n        visualize(node.right, ctx, newX, newY, pathNodes);\r\n    }\r\n}\r\nfunction findNodeInPathWithNode(node, pathNodes) {\r\n    for (let i = 0; i < pathNodes.length; i++) {\r\n        if (pathNodes[i].node === node) {\r\n            return pathNodes[i];\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction fillNodeCircle(ctx, currNode, pathNodes) {\r\n    const nodeInPath = findNodeInPathWithNode(currNode, pathNodes);\r\n    if (nodeInPath === null) {\r\n        return;\r\n    }\r\n    if (nodeInPath.type === TYPES.SOURCE_OR_DESTINATION) {\r\n        ctx.fillStyle = configs.getCanvasNodeSelectedColor();\r\n        ctx.fill();\r\n    }\r\n    else if (nodeInPath.type === TYPES.IN_PATH) {\r\n        ctx.fillStyle = configs.getPathNodeColor();\r\n        ctx.fill();\r\n    }\r\n    else if (nodeInPath.type === TYPES.CURRENT) {\r\n        ctx.fillStyle = configs.getPathCurrentNodeColor();\r\n        ctx.fill();\r\n    }\r\n}\r\nfunction strokeLine(ctx, initialX, initialY, finalX, finalY, radius = configs.getCanvasNodeRadius()) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(initialX, initialY + radius);\r\n    ctx.lineTo(finalX, finalY - radius)\r\n    ctx.stroke();\r\n}","import React from 'react'\r\n\r\nexport default function Dropdown(info) {\r\n\r\n    const props = info.props;\r\n    const handleOnChange = (e) => {\r\n        if (props.onChange) {\r\n            props.onChange(e);\r\n        }\r\n    };\r\n    return (\r\n        <select className=\"dropdown\" defaultValue={'DEFAULT'} onChange={handleOnChange}>\r\n            <option value=\"DEFAULT\" disabled>{props.defaultText}</option>\r\n            {props.options.map(item => {\r\n                return (\r\n                    <option value={item.value} key={item.value} >{item.text}</option>\r\n                )\r\n            })}\r\n        </select >\r\n    )\r\n}\r\n","import Slider from \"./Slider\";\r\nimport * as configs from '../models/Config.js';\r\nimport { AVLContext } from './App.js';\r\nimport { useContext } from 'react';\r\nimport React from 'react';\r\nimport * as visualizer from '../View/Visualizer.js';\r\nimport Dropdown from \"./Dropdown\";\r\n\r\nconst Header = React.forwardRef((props, canvasRef) => {\r\n    const avl = useContext(AVLContext);\r\n    const MAX_ITERATIONS = configs.getMaximumNodes() - configs.getMinimumNodes() + 20;\r\n    const speed = [configs.getMinimumSpeed()];\r\n    speed.length = 1; // speed as an array, limited to 1, so we are passing by reference, allowing speed to be set in real time\r\n    Object.defineProperty(speed, 'length', { writable: false });\r\n    let currentAlgorithm = 'DEFAULT';\r\n\r\n\r\n    const handleNodeOnChange = (value) => {\r\n        let iterations = 0; // failsafe\r\n        while (avl.size() < value && iterations < MAX_ITERATIONS) {\r\n            let random = parseInt(Math.random() * 1000);\r\n            avl.insert(random);\r\n            iterations++;\r\n        }\r\n        iterations = 0;\r\n        while (avl.size() > value && iterations < MAX_ITERATIONS) {\r\n            avl.remove(avl.obtainRandomNodeElement());\r\n            iterations++;\r\n        }\r\n        window.dispatchEvent(new Event('resize')); //useEffect refuses to work, and I don't want to write a custom one for objects, so this will do.\r\n    }\r\n    const handleSpeedOnChange = (value) => {\r\n        speed[0] = value;\r\n    }\r\n    const nodeSliderProps = {\r\n        min_value: configs.getMinimumNodes(),\r\n        max_value: configs.getMaximumNodes(),\r\n        step: 4,\r\n        onChange: handleNodeOnChange\r\n    }\r\n    const speedSliderProps = {\r\n        min_value: configs.getMinimumSpeed(),\r\n        max_value: configs.getMaximumSpeed(),\r\n        step: 20,\r\n        onChange: handleSpeedOnChange\r\n    }\r\n    function runAlgorithm() {\r\n        if (currentAlgorithm === 'DEFAULT') {\r\n            alert('Please select an algorithm!');\r\n            return;\r\n        }\r\n        const ctx = canvasRef.current.getContext('2d');\r\n        switch (currentAlgorithm) {\r\n            case '1':\r\n                if (avl.selectedNodes.length === 0) {\r\n                    alert('Select atleast one node!');\r\n                    return;\r\n                }\r\n                const height = avl.height();\r\n                const loopFind = (i) => {\r\n                    if (i < avl.selectedNodes.length) {\r\n                        visualizer.visualizeFind(avl, ctx, avl.selectedNodes[i].element, speed);\r\n                        setTimeout(function () { loopFind(++i) }, speed * (height - avl.calculateHeight(avl.selectedNodes[i])) + 1000);\r\n                    }\r\n/*                     else {\r\n                        avl.inOrderNodes().filter(node => node.isSelected).forEach(node => node.changeSelectStatus());\r\n                        avl.selectedNodes = [];\r\n                    }\r\n */                };\r\n                loopFind(0);\r\n                break;\r\n            case '2':\r\n                break;\r\n            case '3':\r\n                visualizer.visualizeTreeDiameterPaths(avl,ctx,speed);\r\n                break;\r\n\r\n            case '4':\r\n                if (avl.selectedNodes.length < 2) {\r\n                    alert('Choose at least two nodes!');\r\n                    return;\r\n                }\r\n                visualizer.visualizeAllBetweenChosenNodes(avl, ctx, speed);\r\n/*                 avl.inOrderNodes().filter(node => node.isSelected).forEach(node => node.changeSelectStatus());\r\n                avl.selectedNodes = [];\r\n\r\n */                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    const algoDisplay = {\r\n        display: \"flex\",\r\n        flexDirection: \"row\",\r\n        justifyContent: \"space-between\",\r\n        flexBasis: \"23%\",\r\n    };\r\n    const algoOnChange = (e) => {\r\n        currentAlgorithm = e.target.value;\r\n        avl.inOrderNodes().filter(node => node.isSelected).forEach(node => node.changeSelectStatus());\r\n        avl.selectedNodes = [];\r\n        window.dispatchEvent(new Event('resize')); //redraw canvas, in this case, resize works can also use useContext for canvas.getContext('2d) and avl.draw(context)\r\n    }\r\n    const dropDownOptions = {\r\n        defaultText: \"Choose algorithm...\",\r\n        options: [{\r\n            value: '1',\r\n            text: 'Find nodes'\r\n        },\r\n        {\r\n            value: '2',\r\n            text: 'Lowest common ancestor'\r\n        }, {\r\n            value: '3',\r\n            text: 'Tree diameter paths'\r\n        }, {\r\n            value: '4',\r\n            text: 'All between chosen nodes'\r\n        }],\r\n        onChange: algoOnChange\r\n    };\r\n    return (\r\n        <header className=\"App-Header\">\r\n            <div style={algoDisplay}>\r\n                <Dropdown props={dropDownOptions}></Dropdown>\r\n                <button className=\"btn\" onClick={() => runAlgorithm()}>Run algorithm</button>\r\n\r\n            </div>\r\n            <div>\r\n                <label>Nodes: {nodeSliderProps.min_value} </label>\r\n                <Slider props={nodeSliderProps} />\r\n                <label> {nodeSliderProps.max_value} </label>\r\n            </div>\r\n            <div>\r\n                <label>Speed(ms): {speedSliderProps.min_value} </label>\r\n                <Slider props={speedSliderProps} />\r\n                <label> {speedSliderProps.max_value} </label>\r\n            </div>\r\n\r\n            {/*             <div>\r\n                <button className=\"btn\" onClick={() => zoomIn()}>+</button>\r\n                <button className=\"btn\" onClick={() => console.log('hello')}>-</button>\r\n            </div>\r\n */}        </header>\r\n    )\r\n});\r\nexport default Header;","import React, { useEffect, useContext } from 'react'\r\nimport { AVLContext } from './App.js';\r\n\r\n\r\nconst Canvas = React.forwardRef((props, ref) => {\r\n  let avl = useContext(AVLContext);\r\n  useEffect(() => {\r\n    const canvas = ref.current;\r\n    const context = canvas.getContext('2d');\r\n\r\n    const render = () => {\r\n      avl.draw(context);\r\n    }\r\n\r\n    const clickCanvasPos = (e) => {\r\n      let rect = canvas.getBoundingClientRect();\r\n      let actualWidth = rect.width - rect.x;\r\n      let actualHeight = rect.height;\r\n      let clickedX = e.clientX - rect.left;\r\n      let clickedY = e.clientY - rect.top;\r\n      let canvasPosX = clickedX * (canvas.width / actualWidth);\r\n      let canvasPosY = clickedY * (canvas.height / actualHeight);\r\n      const node = avl.getNodeInPosition(canvasPosX, canvasPosY, avl.root);\r\n      if (node) {\r\n        node.changeSelectStatus();\r\n        if (node.isSelected) {\r\n          avl.selectedNodes.push(node);\r\n        }\r\n        else {\r\n          avl.selectedNodes = avl.selectedNodes.filter(dNode => dNode !== node);\r\n        }\r\n        render();\r\n      }\r\n\r\n    };\r\n    const handleResize = () => {\r\n      var parent = canvas.parentNode,\r\n        styles = getComputedStyle(parent),\r\n        w = parseInt(styles.getPropertyValue(\"width\")),\r\n        h = parseInt(styles.getPropertyValue(\"height\"));\r\n      canvas.width = w;\r\n      canvas.height = h;\r\n      render();\r\n    }\r\n    handleResize();\r\n    fillBinaryTree(avl);\r\n\r\n    render();\r\n    window.addEventListener('resize', handleResize);\r\n    canvas.addEventListener('click', clickCanvasPos);\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', handleResize);\r\n      window.removeEventListener('click', clickCanvasPos)\r\n    }\r\n  }, [avl, ref]);\r\n  return <canvas ref={ref} />\r\n});\r\nfunction fillBinaryTree(avl) {\r\n  // it does double when outside of useEffect, why? print doesn't show it.\r\n  for (let i = 0; i < 20; i++) {\r\n    let random = parseInt(Math.random() * 1000);\r\n    avl.insert(random);\r\n  }\r\n}\r\n\r\nexport default Canvas;","import Canvas from './Canvas.js';\r\nimport React from 'react';\r\n\r\n\r\nconst  Content = React.forwardRef((props, canvasRef) =>{\r\n  return (<main>\r\n    <Canvas ref={canvasRef} />\r\n  </main>);\r\n});\r\n\r\nexport default Content;","\r\nfunction Footer() {\r\n    return (\r\n        <footer>\r\n            <h3>Binary tree visualizer-</h3>\r\n            <a href=\"https://github.com/solmars\">https://github.com/solmars</a>\r\n        </footer>\r\n    )\r\n}\r\n\r\nexport default Footer;\r\n","import Node from './Node.js';\r\nimport BinarySearchTree from './BinarySearchTree.js';\r\n\r\n\r\nexport default class AVLTree extends BinarySearchTree {\r\n\r\n\r\n    updateHeight(node) {\r\n        node.level = 1 + Math.max(this.nodeHeight(node.left), this.nodeHeight(node.right));\r\n    }\r\n\r\n    nodeHeight(node) {\r\n        return node == null ? -1 : node.level;\r\n    }\r\n    balanceFactor(node) {\r\n        return node == null ? 0 : this.nodeHeight(node.right) - this.nodeHeight(node.left);\r\n    }\r\n\r\n    rightRotation(node) {\r\n\r\n        let leftNode = node.left;\r\n        let rightLeftNode = leftNode.right;\r\n        leftNode.right = node;\r\n        node.left = rightLeftNode;\r\n        this.updateHeight(node);\r\n        this.updateHeight(leftNode);\r\n\r\n        return leftNode;\r\n    }\r\n\r\n    leftRotation(node) {\r\n\r\n        let rightNode = node.right;\r\n        let leftRightNode = rightNode.left;\r\n        rightNode.left = node;\r\n        node.right = leftRightNode;\r\n        this.updateHeight(node);\r\n        this.updateHeight(rightNode);\r\n\r\n        return rightNode;\r\n    }\r\n\r\n    twoRotations(node) {\r\n\r\n        if (this.balanceFactor(node) < 0) {\r\n            node.left = this.leftRotation(node.left);\r\n            node = this.rightRotation(node);\r\n        } else {\r\n            node.right = this.rightRotation(node.right);\r\n            node = this.leftRotation(node);\r\n        }\r\n        return node;\r\n    }\r\n\r\n    balanceNode(node) {\r\n        this.updateHeight(node);\r\n        let bf = this.balanceFactor(node);\r\n        if (bf > 1) {\r\n            if (this.nodeHeight(node.right.right) > this.nodeHeight(node.right.left)) {\r\n                node = this.leftRotation(node);\r\n            } else {\r\n                node.right = this.rightRotation(node.right);\r\n                node = this.leftRotation(node);\r\n            }\r\n        }\r\n        else if (bf < -1) {\r\n            if (this.nodeHeight(node.left.left) > this.nodeHeight(node.left.right))\r\n                node = this.rightRotation(node);\r\n            else {\r\n                node.left = this.leftRotation(node.left);\r\n                node = this.rightRotation(node);\r\n            }\r\n\r\n        }\r\n        return node;\r\n\r\n    }\r\n\r\n    insert(element) {\r\n        this.root = this.insertNode(element, this.root);\r\n    }\r\n\r\n    insertNode(element, node) {\r\n        if (node === null) {\r\n            return new Node(element);\r\n        } else if (node.element > element) {\r\n            node.left = this.insertNode(element, node.left);\r\n        } else if (node.element < element) {\r\n            node.right = this.insertNode(element, node.right);\r\n        }\r\n        return this.balanceNode(node);\r\n    }\r\n\r\n    obtainRandomNodeElement() {\r\n\r\n        return this.inOrder()[parseInt(Math.random() * this.size())];\r\n    }\r\n\r\n    remove(element) {\r\n        this.removeNode(element, this.root);\r\n    }\r\n\r\n    removeNode(element, node) {\r\n        if (node === null) {\r\n            return null;\r\n        }\r\n        else if (node.element > element) {\r\n            node.left = this.removeNode(element, node.left);\r\n        } else if (node.element < element) {\r\n            node.right = this.removeNode(element, node.right);\r\n        }\r\n        else {\r\n            if (node.left == null || node.right == null) {\r\n                node = (node.left == null) ? node.right : node.left;\r\n\r\n            } else {\r\n                let smallElem = this.smallestElementOfSubtree(node.right);\r\n                node.element = smallElem;\r\n                node.right = this.removeNode(smallElem, node.right);\r\n            }\r\n        }\r\n        if (node != null) {\r\n            node = this.balanceNode(node);\r\n        }\r\n        return node;\r\n    }\r\n\r\n}","import Node from './Node.js';\r\n\r\n//Note: this is a minimalistic implementation of a BST\r\n\r\nexport default class BinarySearchTree {\r\n    constructor() {\r\n        this.root = null;\r\n    }\r\n\r\n    size() {\r\n        if (this.root == null) {\r\n            return 0;\r\n        }\r\n        return this.calcSize(this.root);\r\n    }\r\n\r\n    calcSize(node) {\r\n        if (node === null) {\r\n            return 0;\r\n        }\r\n        return 1 + this.calcSize(node.left) + this.calcSize(node.right);\r\n    }\r\n    insert(element) {\r\n        if (!element) {\r\n            return;\r\n        }\r\n        if (this.root == null) {\r\n            this.root = new Node(element);\r\n            return;\r\n        }\r\n        this.insertNode(new Node(element), this.root);\r\n    }\r\n    insertNode(newNode, node) {\r\n        if (newNode.element < node.element) {\r\n            if (node.left === null) {\r\n                node.left = newNode;\r\n                return node.left;\r\n            }\r\n            return this.insertNode(newNode, node.left);\r\n        } else if (newNode.element > node.element) {\r\n            if (node.right === null) {\r\n                node.right = newNode;\r\n                return node.right;\r\n            }\r\n            return this.insertNode(newNode, node.right);\r\n        }\r\n        return node;\r\n    }\r\n    remove(element) {\r\n        this.root = this.removeNode(element, this.root);\r\n    }\r\n\r\n    removeNode(element, node) {\r\n\r\n        if (node === null) {\r\n            return null;\r\n        }\r\n\r\n        if (element === node.element) {\r\n            if (node.left === null && node.right == null) { //leaf\r\n                return null;\r\n            }\r\n            if (node.left == null) {   // only right child\r\n                return node.right;\r\n            }\r\n            if (node.right == null) {  // only left child\r\n                return node.left;\r\n            }\r\n            let min = this.smallestElement(node.right);\r\n            node.element = min;\r\n            node.right = this.removeNode(min, node.right);\r\n        } else if (element < node.element) {\r\n            node.left = this.removeNode(element, node.left);\r\n        } else {\r\n            node.right = this.removeNode(element, node.right);\r\n        }\r\n        return node;\r\n    }\r\n    smallestElement() {\r\n        if (this.root === null) {\r\n            return null;\r\n        }\r\n        let node = this.root;\r\n        while (node.left != null) {\r\n            node = node.left;\r\n        }\r\n        return node.element;\r\n    }\r\n    smallestElementOfSubtree(node) {\r\n        if (this.node === null) {\r\n            return null;\r\n        }\r\n        while (node.left != null) {\r\n            node = node.left;\r\n        }\r\n        return node.element;\r\n    }\r\n\r\n    height() {\r\n        if (this.root === null) {\r\n            return -1;\r\n        }\r\n        return this.calculateHeight(this.root);\r\n    }\r\n    calculateHeight(node) {\r\n        if (node === null) {\r\n            return 0;\r\n        }\r\n        let lHeight = this.calculateHeight(node.left);\r\n        let rHeight = this.calculateHeight(node.right);\r\n\r\n\r\n        return lHeight > rHeight ? lHeight + 1 : rHeight + 1;\r\n    }\r\n\r\n    find(elementToFind) {\r\n        if (this.root === null) {\r\n            return null;\r\n        }\r\n        return this.findNode(elementToFind, this.root);\r\n\r\n    }\r\n    findNode(elementToFind, node) {\r\n        if (node === null) {\r\n            return null;\r\n        }\r\n        if (elementToFind === node.element) {\r\n            return node;\r\n        }\r\n        if (node.element > elementToFind) {\r\n            return this.findNode(elementToFind, node.left);\r\n        }\r\n        else {\r\n            return this.findNode(elementToFind, node.right);\r\n        }\r\n    }\r\n    inOrderNodes() {\r\n        let snapshot = [];\r\n        if (this.root != null) {\r\n            this.inOrderNodeSubtree(this.root, snapshot);   // fill the snapshot recursively\r\n        }\r\n        return snapshot;\r\n\r\n    }\r\n    inOrderNodeSubtree(node,snapshot) {\r\n        if (node === null) {\r\n            return;\r\n        }\r\n        this.inOrderNodeSubtree(node.left, snapshot);\r\n        snapshot.push(node);\r\n        this.inOrderNodeSubtree(node.right, snapshot);\r\n\r\n    }\r\n    inOrder() {\r\n        let snapshot = [];\r\n        if (this.root != null) {\r\n            this.inOrderSubtree(this.root, snapshot);   // fill the snapshot recursively\r\n        }\r\n        return snapshot;\r\n    }\r\n    inOrderSubtree(node, snapshot) {\r\n        if (node === null) {\r\n            return;\r\n        }\r\n        this.inOrderSubtree(node.left, snapshot);\r\n        snapshot.push(node.element);\r\n        this.inOrderSubtree(node.right, snapshot);\r\n    }\r\n}\r\n","import Node from './Node.js';\r\n\r\nexport default class DrawableNode extends Node {\r\n    constructor(element) {\r\n        super(element);\r\n        this.canvasPos = {\r\n            x: 0,\r\n            y: 0\r\n        };\r\n        this.radius = 0;\r\n        this.isSelected = false;\r\n    }\r\n    isInPosition(x, y) {\r\n        const canvasX = this.canvasPos.x;\r\n        const canvasY = this.canvasPos.y;\r\n        return isInRange(canvasX - this.radius, x, canvasX + this.radius) && isInRange(canvasY - this.radius, y, canvasY + this.radius);\r\n    }\r\n    changeSelectStatus() {\r\n        this.isSelected = !this.isSelected;\r\n    }\r\n}\r\nfunction isInRange(min, num, max) {\r\n    return num >= min && num <= max;\r\n}","//import Node from './Node.js';\r\nimport AvlTree from './AvlTree.js';\r\nimport DrawableNode from './DrawableNode.js';\r\n\r\nimport * as configs from './Config.js';\r\n\r\nexport default class DrawableAvlTree extends AvlTree {\r\n\r\n    constructor(nodeRadius = configs.getCanvasNodeRadius()) {\r\n        super();\r\n        this.heightIncrease = 0;\r\n        this.nodeRadius = nodeRadius;\r\n        this.canvasWidth = 0;\r\n        this.canvasHeight = 0;\r\n        this.selectedNodes = []; // we'll store the info about selected nodes here.\r\n    }\r\n    insert(element) {\r\n        this.root = this.insertNode(element, this.root);\r\n    }\r\n\r\n    insertNode(element, node) {\r\n        if (node === null) {\r\n            return new DrawableNode(element);\r\n        } else if (node.element > element) {\r\n            node.left = this.insertNode(element, node.left);\r\n        } else if (node.element < element) {\r\n            node.right = this.insertNode(element, node.right);\r\n        }\r\n        return this.balanceNode(node);\r\n    }\r\n/*     drawScaled(context, scale, translatePos) {\r\n\r\n        context.clearRect(0, 0, context.canvas.width, context.canvas.height);\r\n\r\n        context.save();\r\n        context.translate(translatePos.x, translatePos.y);\r\n        context.scale(scale, scale);\r\n        context.beginPath(); // begin custom shape\r\n        this.draw(context);\r\n        context.closePath(); // complete custom shape\r\n        context.stroke();\r\n        context.restore();\r\n    }\r\n */    draw(ctx) {\r\n        if (this.root === null) {\r\n            return;\r\n        }\r\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n        const treeHeight = this.height() + 1;\r\n\r\n        const ratio = ctx.canvas.width / ctx.canvas.height;\r\n        const settleCanvasWidth = (treeHeight) => {\r\n            const shouldBe = this.nodeRadius * 2 * Math.pow(2, treeHeight - 1);\r\n            return shouldBe < configs.getCanvasMaximumWidth() ? shouldBe : configs.getCanvasMaximumWidth();\r\n        }\r\n        const settleCanvasHeight = (width, ratio) => {\r\n            const shouldBe = width / ratio;\r\n            return shouldBe < configs.getCanvasMaximumHeight()\r\n                ? shouldBe\r\n                : configs.getCanvasMaximumHeight();\r\n        }\r\n\r\n        ctx.canvas.width = settleCanvasWidth(treeHeight);\r\n        ctx.canvas.height = settleCanvasHeight(ctx.canvas.width, ratio);\r\n        this.canvasWidth = ctx.canvas.width;\r\n        this.canvasHeight = ctx.canvas.height;\r\n        this.heightIncrease = Math.floor(ctx.canvas.height / (treeHeight - 1));\r\n\r\n        this.drawTree(this.root, ctx, this.canvasWidth / 2, this.canvasHeight - this.canvasHeight + configs.getCanvasNodeRadius(), 0);\r\n    }\r\n    getPosition(level, x, y, isLeft = false) {\r\n        return {\r\n            x: isLeft ? x - ((this.canvasWidth / 2 / Math.pow(2, level))) : x + ((this.canvasWidth / 2 / Math.pow(2, level))),\r\n            y: y + this.heightIncrease\r\n        }\r\n    }\r\n\r\n    drawTree(node, ctx, x, y, level) {\r\n        ctx.font = configs.getCanvasDrawFont();\r\n        node.canvasPos.x = x;\r\n        node.canvasPos.y = y;\r\n        node.radius = this.nodeRadius;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, this.nodeRadius, 0, 2 * Math.PI);\r\n        ctx.stroke();\r\n        if (node.isSelected) {\r\n            ctx.fillStyle = configs.getCanvasNodeSelectedColor();\r\n            ctx.fill();\r\n        }\r\n        ctx.closePath();\r\n        ctx.textAlign = \"center\";\r\n        ctx.strokeText(node.element, x, y + 5);\r\n\r\n        level++;\r\n        if (node.left !== null) {\r\n            let newPos = this.getPosition(level, x, y, true);\r\n            let newX = newPos.x;\r\n            let newY = newPos.y;\r\n            strokeLine(ctx, x, y, newX, newY);\r\n            this.drawTree(node.left, ctx, newX, newY, level);\r\n        }\r\n        if (node.right !== null) {\r\n            let newPos = this.getPosition(level, x, y);\r\n            let newX = newPos.x;\r\n            let newY = newPos.y;\r\n            strokeLine(ctx, x, y, newX, newY);\r\n            this.drawTree(node.right, ctx, newX, newY, level);\r\n        }\r\n    }\r\n    getNodeInPosition(x, y, node) {\r\n        if (node === null) {\r\n            return null;\r\n        }\r\n        if (node.canvasPos.x < x && !node.isInPosition(x, y)) {\r\n            return this.getNodeInPosition(x, y, node.right);\r\n        }\r\n        else if (node.canvasPos.x > x && !node.isInPosition(x, y)) {\r\n            return this.getNodeInPosition(x, y, node.left);\r\n        }\r\n        else {\r\n            if (node.isInPosition(x, y)) {\r\n                return node;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction strokeLine(ctx, initialX, initialY, finalX, finalY, radius = configs.getCanvasNodeRadius()) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(initialX, initialY + radius);\r\n    ctx.lineTo(finalX, finalY - radius)\r\n    ctx.stroke();\r\n}\r\n","import Header from './Header';\nimport Content from './Content';\n\nimport Footer from './Footer';\nimport DrawableAvlTree from '../models/DrawableAvlTree';\nimport React from 'react';\n\nexport const AVLContext = React.createContext();\n\nfunction App() {\n  const avl = new DrawableAvlTree();\n  const canvasRef = React.useRef(null);\n  return (\n    <div className=\"App\">\n      <AVLContext.Provider value={avl}>\n        <Header ref = {canvasRef}/>\n        <Content ref = {canvasRef}/>\n        <Footer />\n      </AVLContext.Provider>\n\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}