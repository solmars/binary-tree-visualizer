{"version":3,"sources":["components/Slider.js","models/Constants.js","models/Config.js","algorithms/TreeAlgorithms.js","View/NodeInPath.js","View/Visualizer.js","components/Header.js","components/Canvas.js","components/Content.js","components/Footer.js","models/Node.js","models/AvlTree.js","models/BinarySearchTree.js","models/DrawableNode.js","models/DrawableAvlTree.js","components/App.js","index.js"],"names":["Slider","props","values","useState","min_value","value","setValue","type","min","max","max_value","step","onChange","e","target","constants","CANVAS_MAXIMUM_WIDTH","CANVAS_MAXIMUM_HEIGHT","MAXIMUM_NODES","MINIMUM_NODES","NODE_RADIUS","NODE_DRAW_FONT","NODE_PATH_COLOR","NODE_SELECTED_COLOR","NODE_CURRENT_COLOR","MINIMUM_SPEED","MAXIMUM_SPEED","getCanvasMaximumWidth","getCanvasMaximumHeight","getMinimumNodes","getMaximumNodes","getMinimumSpeed","getCanvasDrawFont","getCanvasNodeRadius","getCanvasNodeSelectedColor","findNode","elementToFind","node","pathNodes","push","element","left","right","NodeInPath","this","TYPES","visualizeFind","avl","ctx","speed","root","algorithms","pathNodesInPath","i","length","animatePath","current","oneByOneArray","clearRect","canvas","width","height","visualize","Math","floor","configs","visualizePath","setTimeout","x","y","font","beginPath","arc","PI","stroke","currNode","nodeInPath","findNodeInPathWithNode","fillStyle","fill","fillNodeCircle","closePath","textAlign","strokeText","newX","canvasPos","newY","strokeLine","initialX","initialY","finalX","finalY","radius","moveTo","lineTo","Header","React","forwardRef","canvasRef","useContext","AVLContext","MAX_ITERATIONS","Object","defineProperty","writable","nodeSliderProps","iterations","size","random","parseInt","insert","remove","obtainRandomNodeElement","window","dispatchEvent","Event","speedSliderProps","className","style","display","flexDirection","onClick","getContext","selectedNodes","visualizer","inOrderNodes","filter","isSelected","forEach","changeSelectStatus","runAlgorithm","console","log","Canvas","ref","useEffect","render","draw","context","clickCanvasPos","rect","getBoundingClientRect","actualWidth","actualHeight","clickedX","clientX","clickedY","clientY","top","canvasPosX","canvasPosY","getNodeInPosition","dNode","handleResize","parent","parentNode","styles","getComputedStyle","w","getPropertyValue","h","fillBinaryTree","addEventListener","removeEventListener","Content","Footer","href","Node","level","AVLTree","nodeHeight","leftNode","rightLeftNode","updateHeight","rightNode","leftRightNode","balanceFactor","leftRotation","rightRotation","bf","insertNode","balanceNode","inOrder","removeNode","smallElem","smallestElementOfSubtree","calcSize","newNode","smallestElement","calculateHeight","lHeight","rHeight","snapshot","inOrderNodeSubtree","inOrderSubtree","DrawableNode","canvasX","canvasY","isInRange","num","DrawableAvlTree","nodeRadius","heightIncrease","canvasWidth","canvasHeight","treeHeight","ratio","shouldBe","pow","settleCanvasWidth","settleCanvasHeight","drawTree","isLeft","newPos","getPosition","isInPosition","AvlTree","createContext","App","useRef","Provider","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.09b5d2a8.chunk.js","sourcesContent":["\r\nimport React, { useState } from 'react'\r\n\r\nexport default function Slider(props) {\r\n    const values = props.props;\r\n    const [value, setValue] = useState(values.min_value);\r\n    const handleOnChange = (e) => {\r\n        setValue(e.target.value);\r\n        values.onChange(e.target.value);\r\n    }\r\n    return (\r\n        <input type=\"range\" min={values.min_value} max={values.max_value} step={values.step} value={value} onChange={handleOnChange}></input>\r\n    )\r\n}\r\n","const constants = {\r\n    CANVAS_MAXIMUM_WIDTH : 32767,\r\n    CANVAS_MAXIMUM_HEIGHT: 32767,\r\n    MAXIMUM_NODES : 120,\r\n    MINIMUM_NODES:  20,\r\n    NODE_RADIUS: 25,\r\n    NODE_DRAW_FONT: '15px Arial',\r\n    NODE_PATH_COLOR: 'yellow',\r\n    NODE_SELECTED_COLOR: '#00FFFF',\r\n    NODE_CURRENT_COLOR :'green',\r\n    MINIMUM_SPEED:20,\r\n    MAXIMUM_SPEED:1000\r\n};\r\nexport default constants;","import constants from './Constants.js';\r\n\r\nexport function getCanvasMaximumWidth() {\r\n    return constants.CANVAS_MAXIMUM_WIDTH;\r\n}\r\nexport function getCanvasMaximumHeight() {\r\n    return constants.CANVAS_MAXIMUM_HEIGHT;\r\n}\r\nexport function getMinimumNodes() {\r\n    return constants.MINIMUM_NODES;\r\n}\r\nexport function getMaximumNodes() {\r\n    return constants.MAXIMUM_NODES;\r\n}\r\nexport function getMinimumSpeed() {\r\n    return constants.MINIMUM_SPEED;\r\n}\r\nexport function getMaximumSpeed() {\r\n    return constants.MAXIMUM_SPEED;\r\n}\r\nexport function getCanvasDrawFont() {\r\n    return constants.NODE_DRAW_FONT;\r\n} \r\nexport function getCanvasNodeRadius() {\r\n    return constants.NODE_RADIUS;\r\n}\r\nexport function getPathNodeColor() {\r\n    return constants.NODE_PATH_COLOR;\r\n} \r\nexport function getCanvasNodeSelectedColor() {\r\n    return constants.NODE_SELECTED_COLOR;\r\n}\r\nexport function getPathCurrentNodeColor() {\r\n    return constants.NODE_CURRENT_COLOR;\r\n}","export function findNode(elementToFind, node,pathNodes=[]) {\r\n    if (node === null) {\r\n        return null;\r\n    }\r\n    pathNodes.push(node);\r\n\r\n    if (elementToFind === node.element) {\r\n        return pathNodes;\r\n    }\r\n    if (node.element > elementToFind) {\r\n        return findNode(elementToFind, node.left,pathNodes);\r\n    }\r\n    else {\r\n        return findNode(elementToFind, node.right,pathNodes);\r\n    }\r\n}","export  class NodeInPath {\r\n    constructor(node,type) {\r\n        this.node = node;\r\n        this.type = type;\r\n    }\r\n}\r\nexport const TYPES = {\r\n    CURRENT: 'current',\r\n    IN_PATH: 'in_path',\r\n    SOURCE_OR_DESTINATION: 'sdst',\r\n    NOT_YET_TRAVERSED: ''\r\n\r\n};","import * as configs from '../models/Config.js';\r\nimport * as algorithms from '../algorithms/TreeAlgorithms.js';\r\nimport { NodeInPath, TYPES } from './NodeInPath.js';\r\n\r\n//Assumes node positions are set\r\n\r\n\r\nexport function visualizeFind(avl, ctx, elementToFind, speed) {\r\n    if (avl.root === null) {\r\n        return null;\r\n    }\r\n    const pathNodes = algorithms.findNode(elementToFind, avl.root);\r\n    const pathNodesInPath = [];\r\n    pathNodesInPath.push(new NodeInPath(pathNodes[0], TYPES.SOURCE_OR_DESTINATION));\r\n    for (let i = 1; i < pathNodes.length - 1; i++) {\r\n        pathNodesInPath.push(new NodeInPath(pathNodes[i], TYPES.IN_PATH));\r\n    }\r\n    pathNodesInPath.push(new NodeInPath(pathNodes[pathNodes.length - 1], TYPES.SOURCE_OR_DESTINATION));\r\n\r\n    animatePath(avl, ctx, pathNodesInPath, 1, speed);\r\n\r\n}\r\nfunction animatePath(avl, ctx, pathNodes, current, speed) {\r\n    if (current > pathNodes.length) {\r\n        return;\r\n    }\r\n    if (current < pathNodes.length && current !== 1) {\r\n        pathNodes[current - 1].type = TYPES.CURRENT;\r\n    }\r\n    if (current > 2) { // no longer the current one\r\n        pathNodes[current - 2].type = TYPES.IN_PATH;\r\n    }\r\n    const oneByOneArray = [];\r\n    for (let i = 0; i < current; i++) {\r\n        oneByOneArray.push(pathNodes[i]);\r\n    }\r\n    visualizePath(avl, ctx, oneByOneArray);\r\n    setTimeout(function () {\r\n        animatePath(avl, ctx, pathNodes, ++current, speed);\r\n    }, speed[0]);\r\n\r\n}\r\nfunction visualizePath(avl, ctx, pathNodes = []) {\r\n    if (pathNodes.length === 0) return;\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n    visualize(avl.root, ctx, Math.floor(ctx.canvas.width / 2), ctx.canvas.height - ctx.canvas.height + configs.getCanvasNodeRadius(), pathNodes);\r\n}\r\nfunction visualize(node, ctx, x, y, pathNodes) {\r\n    ctx.font = configs.getCanvasDrawFont();\r\n    ctx.beginPath();\r\n    ctx.arc(x, y, configs.getCanvasNodeRadius(), 0, 2 * Math.PI);\r\n    ctx.stroke();\r\n    fillNodeCircle(ctx, node, pathNodes);\r\n    ctx.closePath();\r\n    ctx.textAlign = \"center\";\r\n    ctx.strokeText(node.element, x, y + 5);\r\n    if (node.left !== null) {\r\n        let newX = node.left.canvasPos.x;\r\n        let newY = node.left.canvasPos.y;\r\n        strokeLine(ctx, x, y, newX, newY);\r\n        visualize(node.left, ctx, newX, newY, pathNodes);\r\n    }\r\n    if (node.right !== null) {\r\n        let newX = node.right.canvasPos.x;\r\n        let newY = node.right.canvasPos.y;\r\n        strokeLine(ctx, x, y, newX, newY);\r\n        visualize(node.right, ctx, newX, newY, pathNodes);\r\n    }\r\n}\r\nfunction findNodeInPathWithNode(node, pathNodes) {\r\n    for (let i = 0; i < pathNodes.length; i++) {\r\n        if (pathNodes[i].node === node) {\r\n            return pathNodes[i];\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction fillNodeCircle(ctx, currNode, pathNodes) {\r\n    const nodeInPath = findNodeInPathWithNode(currNode, pathNodes);\r\n    if (nodeInPath === null) {\r\n        return;\r\n    }\r\n    if (nodeInPath.type === TYPES.SOURCE_OR_DESTINATION) {\r\n        ctx.fillStyle = configs.getCanvasNodeSelectedColor();\r\n        ctx.fill();\r\n    }\r\n    else if (nodeInPath.type === TYPES.IN_PATH) {\r\n        ctx.fillStyle = configs.getPathNodeColor();\r\n        ctx.fill();\r\n    }\r\n    else if (nodeInPath.type === TYPES.CURRENT) {\r\n        ctx.fillStyle = configs.getPathCurrentNodeColor();\r\n        ctx.fill();\r\n    }\r\n}\r\nfunction strokeLine(ctx, initialX, initialY, finalX, finalY, radius = configs.getCanvasNodeRadius()) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(initialX, initialY + radius);\r\n    ctx.lineTo(finalX, finalY - radius)\r\n    ctx.stroke();\r\n}","import Slider from \"./Slider\";\r\nimport * as configs from '../models/Config.js';\r\nimport { AVLContext } from './App.js';\r\nimport { useContext } from 'react';\r\nimport React from 'react';\r\nimport * as visualizer from '../View/Visualizer.js';\r\n\r\nconst Header = React.forwardRef((props, canvasRef) => {\r\n    let avl = useContext(AVLContext);\r\n    const MAX_ITERATIONS = configs.getMaximumNodes() - configs.getMinimumNodes() + 20;\r\n    const speed = [configs.getMinimumSpeed()];\r\n    speed.length =1; // speed as an array, limited to 1, so we are passing by reference, allowing speed to be set in real time\r\n    Object.defineProperty(speed, 'length', {writable:false});\r\n\r\n    const handleNodeOnChange = (value) => {\r\n        let iterations = 0; // failsafe\r\n        while (avl.size() < value && iterations < MAX_ITERATIONS) {\r\n            let random = parseInt(Math.random() * 1000);\r\n            avl.insert(random);\r\n            iterations++;\r\n        }\r\n        iterations = 0;\r\n        while (avl.size() > value && iterations < MAX_ITERATIONS) {\r\n            avl.remove(avl.obtainRandomNodeElement());\r\n            iterations++;\r\n        }\r\n        window.dispatchEvent(new Event('resize')); //useEffect refuses to work, and I don't want to write a custom one for objects, so this will do.\r\n    }\r\n    const handleSpeedOnChange = (value) => {\r\n        speed[0] = value;\r\n    }\r\n    const nodeSliderProps = {\r\n        min_value: configs.getMinimumNodes(),\r\n        max_value: configs.getMaximumNodes(),\r\n        step: 4,\r\n        onChange: handleNodeOnChange\r\n    }\r\n    const speedSliderProps = {\r\n        min_value: configs.getMinimumSpeed(),\r\n        max_value: configs.getMaximumSpeed(),\r\n        step: 20,\r\n        onChange: handleSpeedOnChange\r\n    }\r\n    /*     var scale = 1.0;\r\n        var scaleMultiplier = 0.8;\r\n        var startDragOffset = {};\r\n        var mouseDown = false;\r\n    \r\n        var translatePos = {\r\n            x: 1536 / 2,\r\n            y: 768 / 2\r\n        };\r\n     */\r\n    function runAlgorithm() {\r\n        const ctx = canvasRef.current.getContext('2d');\r\n        //TODO: dropbox here\r\n        if(avl.selectedNodes.length ===0) { // for now, but remember to add DFS and stuff.\r\n            return;\r\n        }\r\n        visualizer.visualizeFind(avl,ctx,avl.selectedNodes[0].element,speed);\r\n        //reset selected\r\n        avl.inOrderNodes().filter(node =>  node.isSelected).forEach(node => node.changeSelectStatus());\r\n        avl.selectedNodes = [];\r\n    }\r\n    function zoomIn() {\r\n /*        const canvas = canvasRef.current;\r\n\r\n\r\n       const draw = (scale, translatePos) => {\r\n            const context = canvas.getContext('2d');\r\n            avl.drawScaled(context,scale,translatePos)\r\n        }\r\n        scale /= scaleMultiplier;\r\n        draw(scale, translatePos);\r\n        console.log('hello');\r\n */    }\r\n    /*     window.addEventListener(\"mouseup\", function (evt) {\r\n            mouseDown = false;\r\n        });\r\n    \r\n        window.addEventListener(\"mouseover\", function (evt) {\r\n            mouseDown = false;\r\n        });\r\n    \r\n        window.addEventListener(\"mouseout\", function (evt) {\r\n            mouseDown = false;\r\n        });\r\n    \r\n        window.addEventListener(\"mousemove\", function (evt) {\r\n            if (mouseDown) {\r\n                translatePos.x = evt.clientX - startDragOffset.x;\r\n                translatePos.y = evt.clientY - startDragOffset.y;\r\n            }\r\n        });\r\n     */\r\n        const algoDisplay = {\r\n            display:\"flex\",\r\n            flexDirection: \"row\"\r\n\r\n        };\r\n    return (\r\n        <header className=\"App-Header\">\r\n            <div style = {algoDisplay}>\r\n                <h1>Shortest path</h1>\r\n                <button className=\"btn\" onClick={() => runAlgorithm()}>Run algorithm</button>\r\n\r\n            </div>\r\n            <div>\r\n                <label>Nodes: {nodeSliderProps.min_value} </label>\r\n                <Slider props={nodeSliderProps} />\r\n                <label> {nodeSliderProps.max_value} </label>\r\n            </div>\r\n            <div>\r\n                <label>Speed(ms): {speedSliderProps.min_value} </label>\r\n                <Slider props={speedSliderProps} />\r\n                <label> {speedSliderProps.max_value} </label>\r\n            </div>\r\n\r\n            <div>\r\n                <button className=\"btn\" onClick={() => zoomIn()}>+</button>\r\n                <button className=\"btn\" onClick={() => console.log('hello')}>-</button>\r\n            </div>\r\n        </header>\r\n    )\r\n});\r\nexport default Header;","import React, { useEffect, useContext } from 'react'\r\nimport { AVLContext } from './App.js';\r\n\r\n\r\nconst Canvas = React.forwardRef((props, ref) => {\r\n  let avl = useContext(AVLContext);\r\n  useEffect(() => {\r\n    const canvas = ref.current;\r\n    const render = () => {\r\n      avl.draw(context);\r\n    }\r\n\r\n    const clickCanvasPos = (e) => {\r\n      let rect = canvas.getBoundingClientRect();\r\n      let actualWidth = rect.width - rect.x;\r\n      let actualHeight = rect.height;\r\n      let clickedX = e.clientX - rect.left;\r\n      let clickedY = e.clientY - rect.top;\r\n      let canvasPosX = clickedX * (canvas.width / actualWidth);\r\n      let canvasPosY = clickedY * (canvas.height / actualHeight);\r\n      const node = avl.getNodeInPosition(canvasPosX, canvasPosY, avl.root);\r\n      if (node) {\r\n        node.changeSelectStatus();\r\n        if (node.isSelected) {\r\n          avl.selectedNodes.push(node);\r\n        }\r\n        else {\r\n          avl.selectedNodes = avl.selectedNodes.filter(dNode => dNode !== node);\r\n        }\r\n        render();\r\n      }\r\n    };\r\n    const context = canvas.getContext('2d');\r\n    const handleResize = () => {\r\n      var parent = canvas.parentNode,\r\n        styles = getComputedStyle(parent),\r\n        w = parseInt(styles.getPropertyValue(\"width\")),\r\n        h = parseInt(styles.getPropertyValue(\"height\"));\r\n      canvas.width = w;\r\n      canvas.height = h;\r\n      render();\r\n    }\r\n    handleResize();\r\n    fillBinaryTree(avl);\r\n\r\n    render();\r\n    window.addEventListener('resize', handleResize);\r\n    canvas.addEventListener('click', clickCanvasPos);\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', handleResize);\r\n      window.removeEventListener('click', clickCanvasPos)\r\n    }\r\n  }, [avl, ref]);\r\n  return <canvas ref={ref} />\r\n});\r\nfunction fillBinaryTree(avl) {\r\n  // it does double when outside of useEffect, why? print doesn't show it.\r\n  for (let i = 0; i < 20; i++) {\r\n    let random = parseInt(Math.random() * 1000);\r\n    avl.insert(random);\r\n  }\r\n}\r\n\r\nexport default Canvas;","import Canvas from './Canvas.js';\r\nimport React from 'react';\r\n\r\n\r\nconst  Content = React.forwardRef((props, canvasRef) =>{\r\n  return (<main>\r\n    <Canvas ref={canvasRef} />\r\n  </main>);\r\n});\r\n\r\nexport default Content;","\r\nfunction Footer() {\r\n    return (\r\n        <footer>\r\n            <h3>Binary tree visualizer-</h3>\r\n            <a href=\"https://github.com/solmars\">https://github.com/solmars</a>\r\n        </footer>\r\n    )\r\n}\r\n\r\nexport default Footer;\r\n","export default class Node {\r\n    constructor(element) {\r\n        this.element = element;\r\n        this.left = null;\r\n        this.right =null;\r\n        this.level = 0;\r\n    }\r\n}\r\n","import Node from './Node.js';\r\nimport BinarySearchTree from './BinarySearchTree.js';\r\n\r\n\r\nexport default class AVLTree extends BinarySearchTree {\r\n\r\n\r\n    updateHeight(node) {\r\n        node.level = 1 + Math.max(this.nodeHeight(node.left), this.nodeHeight(node.right));\r\n    }\r\n\r\n    nodeHeight(node) {\r\n        return node == null ? -1 : node.level;\r\n    }\r\n    balanceFactor(node) {\r\n        return node == null ? 0 : this.nodeHeight(node.right) - this.nodeHeight(node.left);\r\n    }\r\n\r\n    rightRotation(node) {\r\n\r\n        let leftNode = node.left;\r\n        let rightLeftNode = leftNode.right;\r\n        leftNode.right = node;\r\n        node.left = rightLeftNode;\r\n        this.updateHeight(node);\r\n        this.updateHeight(leftNode);\r\n\r\n        return leftNode;\r\n    }\r\n\r\n    leftRotation(node) {\r\n\r\n        let rightNode = node.right;\r\n        let leftRightNode = rightNode.left;\r\n        rightNode.left = node;\r\n        node.right = leftRightNode;\r\n        this.updateHeight(node);\r\n        this.updateHeight(rightNode);\r\n\r\n        return rightNode;\r\n    }\r\n\r\n    twoRotations(node) {\r\n\r\n        if (this.balanceFactor(node) < 0) {\r\n            node.left = this.leftRotation(node.left);\r\n            node = this.rightRotation(node);\r\n        } else {\r\n            node.right = this.rightRotation(node.right);\r\n            node = this.leftRotation(node);\r\n        }\r\n        return node;\r\n    }\r\n\r\n    balanceNode(node) {\r\n        this.updateHeight(node);\r\n        let bf = this.balanceFactor(node);\r\n        if (bf > 1) {\r\n            if (this.nodeHeight(node.right.right) > this.nodeHeight(node.right.left)) {\r\n                node = this.leftRotation(node);\r\n            } else {\r\n                node.right = this.rightRotation(node.right);\r\n                node = this.leftRotation(node);\r\n            }\r\n        }\r\n        else if (bf < -1) {\r\n            if (this.nodeHeight(node.left.left) > this.nodeHeight(node.left.right))\r\n                node = this.rightRotation(node);\r\n            else {\r\n                node.left = this.leftRotation(node.left);\r\n                node = this.rightRotation(node);\r\n            }\r\n\r\n        }\r\n        return node;\r\n\r\n    }\r\n\r\n    insert(element) {\r\n        this.root = this.insertNode(element, this.root);\r\n    }\r\n\r\n    insertNode(element, node) {\r\n        if (node === null) {\r\n            return new Node(element);\r\n        } else if (node.element > element) {\r\n            node.left = this.insertNode(element, node.left);\r\n        } else if (node.element < element) {\r\n            node.right = this.insertNode(element, node.right);\r\n        }\r\n        return this.balanceNode(node);\r\n    }\r\n\r\n    obtainRandomNodeElement() {\r\n\r\n        return this.inOrder()[parseInt(Math.random() * this.size())];\r\n    }\r\n\r\n    remove(element) {\r\n        this.removeNode(element, this.root);\r\n    }\r\n\r\n    removeNode(element, node) {\r\n        if (node === null) {\r\n            return null;\r\n        }\r\n        else if (node.element > element) {\r\n            node.left = this.removeNode(element, node.left);\r\n        } else if (node.element < element) {\r\n            node.right = this.removeNode(element, node.right);\r\n        }\r\n        else {\r\n            if (node.left == null || node.right == null) {\r\n                node = (node.left == null) ? node.right : node.left;\r\n\r\n            } else {\r\n                let smallElem = this.smallestElementOfSubtree(node.right);\r\n                node.element = smallElem;\r\n                node.right = this.removeNode(smallElem, node.right);\r\n            }\r\n        }\r\n        if (node != null) {\r\n            node = this.balanceNode(node);\r\n        }\r\n        return node;\r\n    }\r\n\r\n}","import Node from './Node.js';\r\n\r\n//Note: this is a minimalistic implementation of a BST\r\n\r\nexport default class BinarySearchTree {\r\n    constructor() {\r\n        this.root = null;\r\n    }\r\n\r\n    size() {\r\n        if (this.root == null) {\r\n            return 0;\r\n        }\r\n        return this.calcSize(this.root);\r\n    }\r\n\r\n    calcSize(node) {\r\n        if (node === null) {\r\n            return 0;\r\n        }\r\n        return 1 + this.calcSize(node.left) + this.calcSize(node.right);\r\n    }\r\n    insert(element) {\r\n        if (!element) {\r\n            return;\r\n        }\r\n        if (this.root == null) {\r\n            this.root = new Node(element);\r\n            return;\r\n        }\r\n        this.insertNode(new Node(element), this.root);\r\n    }\r\n    insertNode(newNode, node) {\r\n        if (newNode.element < node.element) {\r\n            if (node.left === null) {\r\n                node.left = newNode;\r\n                return node.left;\r\n            }\r\n            return this.insertNode(newNode, node.left);\r\n        } else if (newNode.element > node.element) {\r\n            if (node.right === null) {\r\n                node.right = newNode;\r\n                return node.right;\r\n            }\r\n            return this.insertNode(newNode, node.right);\r\n        }\r\n        return node;\r\n    }\r\n    remove(element) {\r\n        this.root = this.removeNode(element, this.root);\r\n    }\r\n\r\n    removeNode(element, node) {\r\n\r\n        if (node === null) {\r\n            return null;\r\n        }\r\n\r\n        if (element === node.element) {\r\n            if (node.left === null && node.right == null) { //leaf\r\n                return null;\r\n            }\r\n            if (node.left == null) {   // only right child\r\n                return node.right;\r\n            }\r\n            if (node.right == null) {  // only left child\r\n                return node.left;\r\n            }\r\n            let min = this.smallestElement(node.right);\r\n            node.element = min;\r\n            node.right = this.removeNode(min, node.right);\r\n        } else if (element < node.element) {\r\n            node.left = this.removeNode(element, node.left);\r\n        } else {\r\n            node.right = this.removeNode(element, node.right);\r\n        }\r\n        return node;\r\n    }\r\n    smallestElement() {\r\n        if (this.root === null) {\r\n            return null;\r\n        }\r\n        let node = this.root;\r\n        while (node.left != null) {\r\n            node = node.left;\r\n        }\r\n        return node.element;\r\n    }\r\n    smallestElementOfSubtree(node) {\r\n        if (this.node === null) {\r\n            return null;\r\n        }\r\n        while (node.left != null) {\r\n            node = node.left;\r\n        }\r\n        return node.element;\r\n    }\r\n\r\n    height() {\r\n        if (this.root === null) {\r\n            return -1;\r\n        }\r\n        return this.calculateHeight(this.root);\r\n    }\r\n    calculateHeight(node) {\r\n        if (node === null) {\r\n            return 0;\r\n        }\r\n        let lHeight = this.calculateHeight(node.left);\r\n        let rHeight = this.calculateHeight(node.right);\r\n\r\n\r\n        return lHeight > rHeight ? lHeight + 1 : rHeight + 1;\r\n    }\r\n\r\n    find(elementToFind) {\r\n        if (this.root === null) {\r\n            return null;\r\n        }\r\n        return this.findNode(elementToFind, this.root);\r\n\r\n    }\r\n    findNode(elementToFind, node) {\r\n        if (node === null) {\r\n            return null;\r\n        }\r\n        if (elementToFind === node.element) {\r\n            return node;\r\n        }\r\n        if (node.element > elementToFind) {\r\n            return this.findNode(elementToFind, node.left);\r\n        }\r\n        else {\r\n            return this.findNode(elementToFind, node.right);\r\n        }\r\n    }\r\n    inOrderNodes() {\r\n        let snapshot = [];\r\n        if (this.root != null) {\r\n            this.inOrderNodeSubtree(this.root, snapshot);   // fill the snapshot recursively\r\n        }\r\n        return snapshot;\r\n\r\n    }\r\n    inOrderNodeSubtree(node,snapshot) {\r\n        if (node === null) {\r\n            return;\r\n        }\r\n        this.inOrderNodeSubtree(node.left, snapshot);\r\n        snapshot.push(node);\r\n        this.inOrderNodeSubtree(node.right, snapshot);\r\n\r\n    }\r\n    inOrder() {\r\n        let snapshot = [];\r\n        if (this.root != null) {\r\n            this.inOrderSubtree(this.root, snapshot);   // fill the snapshot recursively\r\n        }\r\n        return snapshot;\r\n    }\r\n    inOrderSubtree(node, snapshot) {\r\n        if (node === null) {\r\n            return;\r\n        }\r\n        this.inOrderSubtree(node.left, snapshot);\r\n        snapshot.push(node.element);\r\n        this.inOrderSubtree(node.right, snapshot);\r\n    }\r\n}\r\n","import Node from './Node.js';\r\n\r\nexport default class DrawableNode extends Node {\r\n    constructor(element) {\r\n        super(element);\r\n        this.canvasPos = {\r\n            x: 0,\r\n            y: 0\r\n        };\r\n        this.radius = 0;\r\n        this.isSelected = false;\r\n    }\r\n    isInPosition(x, y) {\r\n        const canvasX = this.canvasPos.x;\r\n        const canvasY = this.canvasPos.y;\r\n        return isInRange(canvasX - this.radius, x, canvasX + this.radius) && isInRange(canvasY - this.radius, y, canvasY + this.radius);\r\n    }\r\n    changeSelectStatus() {\r\n        this.isSelected = !this.isSelected;\r\n    }\r\n}\r\nfunction isInRange(min, num, max) {\r\n    return num >= min && num <= max;\r\n}","//import Node from './Node.js';\r\nimport AvlTree from './AvlTree.js';\r\nimport DrawableNode from './DrawableNode.js';\r\n\r\nimport * as configs from './Config.js';\r\n\r\nexport default class DrawableAvlTree extends AvlTree {\r\n\r\n    constructor(nodeRadius = configs.getCanvasNodeRadius()) {\r\n        super();\r\n        this.heightIncrease = 0;\r\n        this.nodeRadius = nodeRadius;\r\n        this.canvasWidth = 0;\r\n        this.canvasHeight = 0;\r\n        this.selectedNodes = []; // we'll store the info about selected nodes here.\r\n    }\r\n    insert(element) {\r\n        this.root = this.insertNode(element, this.root);\r\n    }\r\n\r\n    insertNode(element, node) {\r\n        if (node === null) {\r\n            return new DrawableNode(element);\r\n        } else if (node.element > element) {\r\n            node.left = this.insertNode(element, node.left);\r\n        } else if (node.element < element) {\r\n            node.right = this.insertNode(element, node.right);\r\n        }\r\n        return this.balanceNode(node);\r\n    }\r\n/*     drawScaled(context, scale, translatePos) {\r\n\r\n        context.clearRect(0, 0, context.canvas.width, context.canvas.height);\r\n\r\n        context.save();\r\n        context.translate(translatePos.x, translatePos.y);\r\n        context.scale(scale, scale);\r\n        context.beginPath(); // begin custom shape\r\n        this.draw(context);\r\n        context.closePath(); // complete custom shape\r\n        context.stroke();\r\n        context.restore();\r\n    }\r\n */    draw(ctx) {\r\n        if (this.root === null) {\r\n            return;\r\n        }\r\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n        const treeHeight = this.height() + 1;\r\n\r\n        const ratio = ctx.canvas.width / ctx.canvas.height;\r\n        const settleCanvasWidth = (treeHeight) => {\r\n            const shouldBe = this.nodeRadius * 2 * Math.pow(2, treeHeight - 1);\r\n            return shouldBe < configs.getCanvasMaximumWidth() ? shouldBe : configs.getCanvasMaximumWidth();\r\n        }\r\n        const settleCanvasHeight = (width, ratio) => {\r\n            const shouldBe = width / ratio;\r\n            return shouldBe < configs.getCanvasMaximumHeight()\r\n                ? shouldBe\r\n                : configs.getCanvasMaximumHeight();\r\n        }\r\n\r\n        ctx.canvas.width = settleCanvasWidth(treeHeight);\r\n        ctx.canvas.height = settleCanvasHeight(ctx.canvas.width, ratio);\r\n        this.canvasWidth = ctx.canvas.width;\r\n        this.canvasHeight = ctx.canvas.height;\r\n        this.heightIncrease = Math.floor(ctx.canvas.height / (treeHeight - 1));\r\n\r\n        this.drawTree(this.root, ctx, this.canvasWidth / 2, this.canvasHeight - this.canvasHeight + configs.getCanvasNodeRadius(), 0);\r\n    }\r\n    getPosition(level, x, y, isLeft = false) {\r\n        return {\r\n            x: isLeft ? x - ((this.canvasWidth / 2 / Math.pow(2, level))) : x + ((this.canvasWidth / 2 / Math.pow(2, level))),\r\n            y: y + this.heightIncrease\r\n        }\r\n    }\r\n\r\n    drawTree(node, ctx, x, y, level) {\r\n        ctx.font = configs.getCanvasDrawFont();\r\n        node.canvasPos.x = x;\r\n        node.canvasPos.y = y;\r\n        node.radius = this.nodeRadius;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, this.nodeRadius, 0, 2 * Math.PI);\r\n        ctx.stroke();\r\n        if (node.isSelected) {\r\n            ctx.fillStyle = configs.getCanvasNodeSelectedColor();\r\n            ctx.fill();\r\n        }\r\n        ctx.closePath();\r\n        ctx.textAlign = \"center\";\r\n        ctx.strokeText(node.element, x, y + 5);\r\n\r\n        level++;\r\n        if (node.left !== null) {\r\n            let newPos = this.getPosition(level, x, y, true);\r\n            let newX = newPos.x;\r\n            let newY = newPos.y;\r\n            strokeLine(ctx, x, y, newX, newY);\r\n            this.drawTree(node.left, ctx, newX, newY, level);\r\n        }\r\n        if (node.right !== null) {\r\n            let newPos = this.getPosition(level, x, y);\r\n            let newX = newPos.x;\r\n            let newY = newPos.y;\r\n            strokeLine(ctx, x, y, newX, newY);\r\n            this.drawTree(node.right, ctx, newX, newY, level);\r\n        }\r\n    }\r\n    getNodeInPosition(x, y, node) {\r\n        if (node === null) {\r\n            return null;\r\n        }\r\n        if (node.canvasPos.x < x && !node.isInPosition(x, y)) {\r\n            return this.getNodeInPosition(x, y, node.right);\r\n        }\r\n        else if (node.canvasPos.x > x && !node.isInPosition(x, y)) {\r\n            return this.getNodeInPosition(x, y, node.left);\r\n        }\r\n        else {\r\n            if (node.isInPosition(x, y)) {\r\n                return node;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction strokeLine(ctx, initialX, initialY, finalX, finalY, radius = configs.getCanvasNodeRadius()) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(initialX, initialY + radius);\r\n    ctx.lineTo(finalX, finalY - radius)\r\n    ctx.stroke();\r\n}\r\n","import Header from './Header';\nimport Content from './Content';\n\nimport Footer from './Footer';\nimport DrawableAvlTree from '../models/DrawableAvlTree';\nimport React from 'react';\n\nexport const AVLContext = React.createContext();\n\nfunction App() {\n  const avl = new DrawableAvlTree();\n  const canvasRef = React.useRef(null);\n  return (\n    <div className=\"App\">\n      <AVLContext.Provider value={avl}>\n        <Header ref = {canvasRef}/>\n        <Content ref = {canvasRef}/>\n        <Footer />\n      </AVLContext.Provider>\n\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}